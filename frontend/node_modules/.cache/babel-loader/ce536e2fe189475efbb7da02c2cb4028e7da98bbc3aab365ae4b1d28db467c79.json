{"ast":null,"code":"// src/queryClient.ts\nimport { functionalUpdate, hashKey, hashQueryKeyByOptions, noop, partialMatchKey, resolveStaleTime, skipToken } from \"./utils.js\";\nimport { QueryCache } from \"./queryCache.js\";\nimport { MutationCache } from \"./mutationCache.js\";\nimport { focusManager } from \"./focusManager.js\";\nimport { onlineManager } from \"./onlineManager.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { infiniteQueryBehavior } from \"./infiniteQueryBehavior.js\";\nvar QueryClient = class {\n  #queryCache;\n  #mutationCache;\n  #defaultOptions;\n  #queryDefaults;\n  #mutationDefaults;\n  #mountCount;\n  #unsubscribeFocus;\n  #unsubscribeOnline;\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.#queryCache = config.queryCache || new QueryCache();\n    this.#mutationCache = config.mutationCache || new MutationCache();\n    this.#defaultOptions = config.defaultOptions || {};\n    this.#queryDefaults = /* @__PURE__ */new Map();\n    this.#mutationDefaults = /* @__PURE__ */new Map();\n    this.#mountCount = 0;\n  }\n  mount() {\n    this.#mountCount++;\n    if (this.#mountCount !== 1) return;\n    this.#unsubscribeFocus = focusManager.subscribe(async focused => {\n      if (focused) {\n        await this.resumePausedMutations();\n        this.#queryCache.onFocus();\n      }\n    });\n    this.#unsubscribeOnline = onlineManager.subscribe(async online => {\n      if (online) {\n        await this.resumePausedMutations();\n        this.#queryCache.onOnline();\n      }\n    });\n  }\n  unmount() {\n    this.#mountCount--;\n    if (this.#mountCount !== 0) return;\n    this.#unsubscribeFocus?.();\n    this.#unsubscribeFocus = void 0;\n    this.#unsubscribeOnline?.();\n    this.#unsubscribeOnline = void 0;\n  }\n  isFetching(filters) {\n    return this.#queryCache.findAll({\n      ...filters,\n      fetchStatus: \"fetching\"\n    }).length;\n  }\n  isMutating(filters) {\n    return this.#mutationCache.findAll({\n      ...filters,\n      status: \"pending\"\n    }).length;\n  }\n  getQueryData(queryKey) {\n    const options = this.defaultQueryOptions({\n      queryKey\n    });\n    return this.#queryCache.get(options.queryHash)?.state.data;\n  }\n  ensureQueryData(options) {\n    const cachedData = this.getQueryData(options.queryKey);\n    if (cachedData === void 0) return this.fetchQuery(options);else {\n      const defaultedOptions = this.defaultQueryOptions(options);\n      const query = this.#queryCache.build(this, defaultedOptions);\n      if (options.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {\n        void this.prefetchQuery(defaultedOptions);\n      }\n      return Promise.resolve(cachedData);\n    }\n  }\n  getQueriesData(filters) {\n    return this.#queryCache.findAll(filters).map(_ref => {\n      let {\n        queryKey,\n        state\n      } = _ref;\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n  setQueryData(queryKey, updater, options) {\n    const defaultedOptions = this.defaultQueryOptions({\n      queryKey\n    });\n    const query = this.#queryCache.get(defaultedOptions.queryHash);\n    const prevData = query?.state.data;\n    const data = functionalUpdate(updater, prevData);\n    if (data === void 0) {\n      return void 0;\n    }\n    return this.#queryCache.build(this, defaultedOptions).setData(data, {\n      ...options,\n      manual: true\n    });\n  }\n  setQueriesData(filters, updater, options) {\n    return notifyManager.batch(() => this.#queryCache.findAll(filters).map(_ref2 => {\n      let {\n        queryKey\n      } = _ref2;\n      return [queryKey, this.setQueryData(queryKey, updater, options)];\n    }));\n  }\n  getQueryState(queryKey) {\n    const options = this.defaultQueryOptions({\n      queryKey\n    });\n    return this.#queryCache.get(options.queryHash)?.state;\n  }\n  removeQueries(filters) {\n    const queryCache = this.#queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query);\n      });\n    });\n  }\n  resetQueries(filters, options) {\n    const queryCache = this.#queryCache;\n    const refetchFilters = {\n      type: \"active\",\n      ...filters\n    };\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset();\n      });\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n  cancelQueries() {\n    let filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let cancelOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const defaultedCancelOptions = {\n      revert: true,\n      ...cancelOptions\n    };\n    const promises = notifyManager.batch(() => this.#queryCache.findAll(filters).map(query => query.cancel(defaultedCancelOptions)));\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n  invalidateQueries() {\n    let filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach(query => {\n        query.invalidate();\n      });\n      if (filters.refetchType === \"none\") {\n        return Promise.resolve();\n      }\n      const refetchFilters = {\n        ...filters,\n        type: filters.refetchType ?? filters.type ?? \"active\"\n      };\n      return this.refetchQueries(refetchFilters, options);\n    });\n  }\n  refetchQueries() {\n    let filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let options = arguments.length > 1 ? arguments[1] : undefined;\n    const fetchOptions = {\n      ...options,\n      cancelRefetch: options?.cancelRefetch ?? true\n    };\n    const promises = notifyManager.batch(() => this.#queryCache.findAll(filters).filter(query => !query.isDisabled()).map(query => {\n      let promise = query.fetch(void 0, fetchOptions);\n      if (!fetchOptions.throwOnError) {\n        promise = promise.catch(noop);\n      }\n      return query.state.fetchStatus === \"paused\" ? Promise.resolve() : promise;\n    }));\n    return Promise.all(promises).then(noop);\n  }\n  fetchQuery(options) {\n    const defaultedOptions = this.defaultQueryOptions(options);\n    if (defaultedOptions.retry === void 0) {\n      defaultedOptions.retry = false;\n    }\n    const query = this.#queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query)) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n  prefetchQuery(options) {\n    return this.fetchQuery(options).then(noop).catch(noop);\n  }\n  fetchInfiniteQuery(options) {\n    options.behavior = infiniteQueryBehavior(options.pages);\n    return this.fetchQuery(options);\n  }\n  prefetchInfiniteQuery(options) {\n    return this.fetchInfiniteQuery(options).then(noop).catch(noop);\n  }\n  ensureInfiniteQueryData(options) {\n    options.behavior = infiniteQueryBehavior(options.pages);\n    return this.ensureQueryData(options);\n  }\n  resumePausedMutations() {\n    if (onlineManager.isOnline()) {\n      return this.#mutationCache.resumePausedMutations();\n    }\n    return Promise.resolve();\n  }\n  getQueryCache() {\n    return this.#queryCache;\n  }\n  getMutationCache() {\n    return this.#mutationCache;\n  }\n  getDefaultOptions() {\n    return this.#defaultOptions;\n  }\n  setDefaultOptions(options) {\n    this.#defaultOptions = options;\n  }\n  setQueryDefaults(queryKey, options) {\n    this.#queryDefaults.set(hashKey(queryKey), {\n      queryKey,\n      defaultOptions: options\n    });\n  }\n  getQueryDefaults(queryKey) {\n    const defaults = [...this.#queryDefaults.values()];\n    let result = {};\n    defaults.forEach(queryDefault => {\n      if (partialMatchKey(queryKey, queryDefault.queryKey)) {\n        result = {\n          ...result,\n          ...queryDefault.defaultOptions\n        };\n      }\n    });\n    return result;\n  }\n  setMutationDefaults(mutationKey, options) {\n    this.#mutationDefaults.set(hashKey(mutationKey), {\n      mutationKey,\n      defaultOptions: options\n    });\n  }\n  getMutationDefaults(mutationKey) {\n    const defaults = [...this.#mutationDefaults.values()];\n    let result = {};\n    defaults.forEach(queryDefault => {\n      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {\n        result = {\n          ...result,\n          ...queryDefault.defaultOptions\n        };\n      }\n    });\n    return result;\n  }\n  defaultQueryOptions(options) {\n    if (options._defaulted) {\n      return options;\n    }\n    const defaultedOptions = {\n      ...this.#defaultOptions.queries,\n      ...this.getQueryDefaults(options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n    }\n    if (defaultedOptions.refetchOnReconnect === void 0) {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== \"always\";\n    }\n    if (defaultedOptions.throwOnError === void 0) {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense;\n    }\n    if (!defaultedOptions.networkMode && defaultedOptions.persister) {\n      defaultedOptions.networkMode = \"offlineFirst\";\n    }\n    if (defaultedOptions.enabled !== true && defaultedOptions.queryFn === skipToken) {\n      defaultedOptions.enabled = false;\n    }\n    return defaultedOptions;\n  }\n  defaultMutationOptions(options) {\n    if (options?._defaulted) {\n      return options;\n    }\n    return {\n      ...this.#defaultOptions.mutations,\n      ...(options?.mutationKey && this.getMutationDefaults(options.mutationKey)),\n      ...options,\n      _defaulted: true\n    };\n  }\n  clear() {\n    this.#queryCache.clear();\n    this.#mutationCache.clear();\n  }\n};\nexport { QueryClient };","map":{"version":3,"names":["functionalUpdate","hashKey","hashQueryKeyByOptions","noop","partialMatchKey","resolveStaleTime","skipToken","QueryCache","MutationCache","focusManager","onlineManager","notifyManager","infiniteQueryBehavior","QueryClient","queryCache","mutationCache","defaultOptions","queryDefaults","mutationDefaults","mountCount","unsubscribeFocus","unsubscribeOnline","constructor","config","arguments","length","undefined","Map","mount","subscribe","focused","resumePausedMutations","onFocus","online","onOnline","unmount","isFetching","filters","findAll","fetchStatus","isMutating","status","getQueryData","queryKey","options","defaultQueryOptions","get","queryHash","state","data","ensureQueryData","cachedData","fetchQuery","defaultedOptions","query","build","revalidateIfStale","isStaleByTime","staleTime","prefetchQuery","Promise","resolve","getQueriesData","map","_ref","setQueryData","updater","prevData","setData","manual","setQueriesData","batch","_ref2","getQueryState","removeQueries","forEach","remove","resetQueries","refetchFilters","type","reset","refetchQueries","cancelQueries","cancelOptions","defaultedCancelOptions","revert","promises","cancel","all","then","catch","invalidateQueries","invalidate","refetchType","fetchOptions","cancelRefetch","filter","isDisabled","promise","fetch","throwOnError","retry","fetchInfiniteQuery","behavior","pages","prefetchInfiniteQuery","ensureInfiniteQueryData","isOnline","getQueryCache","getMutationCache","getDefaultOptions","setDefaultOptions","setQueryDefaults","set","getQueryDefaults","defaults","values","result","queryDefault","setMutationDefaults","mutationKey","getMutationDefaults","_defaulted","queries","refetchOnReconnect","networkMode","suspense","persister","enabled","queryFn","defaultMutationOptions","mutations","clear"],"sources":["C:\\Users\\syucedag\\Desktop\\all_projects\\sevda\\mygit\\testApplication\\frontend\\node_modules\\@tanstack\\query-core\\src\\queryClient.ts"],"sourcesContent":["import {\n  functionalUpdate,\n  hashKey,\n  hashQueryKeyByOptions,\n  noop,\n  partialMatchKey,\n  resolveStaleTime,\n  skipToken,\n} from './utils'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { notifyManager } from './notifyManager'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\nimport type {\n  CancelOptions,\n  DataTag,\n  DefaultError,\n  DefaultOptions,\n  DefaultedQueryObserverOptions,\n  EnsureInfiniteQueryDataOptions,\n  EnsureQueryDataOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  NoInfer,\n  OmitKeyof,\n  QueryClientConfig,\n  QueryKey,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  SetDataOptions,\n} from './types'\nimport type { QueryState } from './query'\nimport type { MutationFilters, QueryFilters, Updater } from './utils'\n\n// TYPES\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: OmitKeyof<QueryOptions<any, any, any>, 'queryKey'>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  #queryCache: QueryCache\n  #mutationCache: MutationCache\n  #defaultOptions: DefaultOptions\n  #queryDefaults: Map<string, QueryDefaults>\n  #mutationDefaults: Map<string, MutationDefaults>\n  #mountCount: number\n  #unsubscribeFocus?: () => void\n  #unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.#queryCache = config.queryCache || new QueryCache()\n    this.#mutationCache = config.mutationCache || new MutationCache()\n    this.#defaultOptions = config.defaultOptions || {}\n    this.#queryDefaults = new Map()\n    this.#mutationDefaults = new Map()\n    this.#mountCount = 0\n  }\n\n  mount(): void {\n    this.#mountCount++\n    if (this.#mountCount !== 1) return\n\n    this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {\n      if (focused) {\n        await this.resumePausedMutations()\n        this.#queryCache.onFocus()\n      }\n    })\n    this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {\n      if (online) {\n        await this.resumePausedMutations()\n        this.#queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.#mountCount--\n    if (this.#mountCount !== 0) return\n\n    this.#unsubscribeFocus?.()\n    this.#unsubscribeFocus = undefined\n\n    this.#unsubscribeOnline?.()\n    this.#unsubscribeOnline = undefined\n  }\n\n  isFetching(filters?: QueryFilters): number {\n    return this.#queryCache.findAll({ ...filters, fetchStatus: 'fetching' })\n      .length\n  }\n\n  isMutating(filters?: MutationFilters): number {\n    return this.#mutationCache.findAll({ ...filters, status: 'pending' }).length\n  }\n\n  getQueryData<\n    TQueryFnData = unknown,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = TTaggedQueryKey extends DataTag<\n      unknown,\n      infer TaggedValue\n    >\n      ? TaggedValue\n      : TQueryFnData,\n  >(queryKey: TTaggedQueryKey): TInferredQueryFnData | undefined\n  getQueryData(queryKey: QueryKey) {\n    const options = this.defaultQueryOptions({ queryKey })\n    return this.#queryCache.get(options.queryHash)?.state.data\n  }\n\n  ensureQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: EnsureQueryDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const cachedData = this.getQueryData<TData>(options.queryKey)\n\n    if (cachedData === undefined) return this.fetchQuery(options)\n    else {\n      const defaultedOptions = this.defaultQueryOptions(options)\n      const query = this.#queryCache.build(this, defaultedOptions)\n\n      if (\n        options.revalidateIfStale &&\n        query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))\n      ) {\n        void this.prefetchQuery(defaultedOptions)\n      }\n\n      return Promise.resolve(cachedData)\n    }\n  }\n\n  getQueriesData<TQueryFnData = unknown>(\n    filters: QueryFilters,\n  ): Array<[QueryKey, TQueryFnData | undefined]> {\n    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {\n      const data = state.data as TQueryFnData | undefined\n      return [queryKey, data]\n    })\n  }\n\n  setQueryData<\n    TQueryFnData = unknown,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = TTaggedQueryKey extends DataTag<\n      unknown,\n      infer TaggedValue\n    >\n      ? TaggedValue\n      : TQueryFnData,\n  >(\n    queryKey: TTaggedQueryKey,\n    updater: Updater<\n      NoInfer<TInferredQueryFnData> | undefined,\n      NoInfer<TInferredQueryFnData> | undefined\n    >,\n    options?: SetDataOptions,\n  ): TInferredQueryFnData | undefined {\n    const defaultedOptions = this.defaultQueryOptions<\n      any,\n      any,\n      unknown,\n      any,\n      QueryKey\n    >({ queryKey })\n\n    const query = this.#queryCache.get<TInferredQueryFnData>(\n      defaultedOptions.queryHash,\n    )\n    const prevData = query?.state.data\n    const data = functionalUpdate(updater, prevData)\n\n    if (data === undefined) {\n      return undefined\n    }\n\n    return this.#queryCache\n      .build(this, defaultedOptions)\n      .setData(data, { ...options, manual: true })\n  }\n\n  setQueriesData<TQueryFnData>(\n    filters: QueryFilters,\n    updater: Updater<TQueryFnData | undefined, TQueryFnData | undefined>,\n    options?: SetDataOptions,\n  ): Array<[QueryKey, TQueryFnData | undefined]> {\n    return notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .map(({ queryKey }) => [\n          queryKey,\n          this.setQueryData<TQueryFnData>(queryKey, updater, options),\n        ]),\n    )\n  }\n\n  getQueryState<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = TTaggedQueryKey extends DataTag<\n      unknown,\n      infer TaggedValue\n    >\n      ? TaggedValue\n      : TQueryFnData,\n  >(\n    queryKey: TTaggedQueryKey,\n  ): QueryState<TInferredQueryFnData, TError> | undefined {\n    const options = this.defaultQueryOptions({ queryKey })\n    return this.#queryCache.get<TInferredQueryFnData, TError>(options.queryHash)\n      ?.state\n  }\n\n  removeQueries(filters?: QueryFilters): void {\n    const queryCache = this.#queryCache\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query)\n      })\n    })\n  }\n\n  resetQueries(filters?: QueryFilters, options?: ResetOptions): Promise<void> {\n    const queryCache = this.#queryCache\n\n    const refetchFilters: RefetchQueryFilters = {\n      type: 'active',\n      ...filters,\n    }\n\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset()\n      })\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  cancelQueries(\n    filters: QueryFilters = {},\n    cancelOptions: CancelOptions = {},\n  ): Promise<void> {\n    const defaultedCancelOptions = { revert: true, ...cancelOptions }\n\n    const promises = notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .map((query) => query.cancel(defaultedCancelOptions)),\n    )\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries(\n    filters: InvalidateQueryFilters = {},\n    options: InvalidateOptions = {},\n  ): Promise<void> {\n    return notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach((query) => {\n        query.invalidate()\n      })\n\n      if (filters.refetchType === 'none') {\n        return Promise.resolve()\n      }\n      const refetchFilters: RefetchQueryFilters = {\n        ...filters,\n        type: filters.refetchType ?? filters.type ?? 'active',\n      }\n      return this.refetchQueries(refetchFilters, options)\n    })\n  }\n\n  refetchQueries(\n    filters: RefetchQueryFilters = {},\n    options?: RefetchOptions,\n  ): Promise<void> {\n    const fetchOptions = {\n      ...options,\n      cancelRefetch: options?.cancelRefetch ?? true,\n    }\n    const promises = notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .filter((query) => !query.isDisabled())\n        .map((query) => {\n          let promise = query.fetch(undefined, fetchOptions)\n          if (!fetchOptions.throwOnError) {\n            promise = promise.catch(noop)\n          }\n          return query.state.fetchStatus === 'paused'\n            ? Promise.resolve()\n            : promise\n        }),\n    )\n\n    return Promise.all(promises).then(noop)\n  }\n\n  fetchQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options: FetchQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<TData> {\n    const defaultedOptions = this.defaultQueryOptions(options)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (defaultedOptions.retry === undefined) {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.#queryCache.build(this, defaultedOptions)\n\n    return query.isStaleByTime(\n      resolveStaleTime(defaultedOptions.staleTime, query),\n    )\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchQuery(options).then(noop).catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>> {\n    options.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData,\n      TPageParam\n    >(options.pages)\n    return this.fetchQuery(options as any)\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(options).then(noop).catch(noop)\n  }\n\n  ensureInfiniteQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: EnsureInfiniteQueryDataOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>> {\n    options.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData,\n      TPageParam\n    >(options.pages)\n\n    return this.ensureQueryData(options as any)\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    if (onlineManager.isOnline()) {\n      return this.#mutationCache.resumePausedMutations()\n    }\n    return Promise.resolve()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.#queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.#mutationCache\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.#defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.#defaultOptions = options\n  }\n\n  setQueryDefaults<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryData = TQueryFnData,\n  >(\n    queryKey: QueryKey,\n    options: Partial<\n      OmitKeyof<\n        QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>,\n        'queryKey'\n      >\n    >,\n  ): void {\n    this.#queryDefaults.set(hashKey(queryKey), {\n      queryKey,\n      defaultOptions: options,\n    })\n  }\n\n  getQueryDefaults(\n    queryKey: QueryKey,\n  ): OmitKeyof<QueryObserverOptions<any, any, any, any, any>, 'queryKey'> {\n    const defaults = [...this.#queryDefaults.values()]\n\n    let result: OmitKeyof<\n      QueryObserverOptions<any, any, any, any, any>,\n      'queryKey'\n    > = {}\n\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(queryKey, queryDefault.queryKey)) {\n        result = { ...result, ...queryDefault.defaultOptions }\n      }\n    })\n    return result\n  }\n\n  setMutationDefaults<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = void,\n    TContext = unknown,\n  >(\n    mutationKey: MutationKey,\n    options: OmitKeyof<\n      MutationObserverOptions<TData, TError, TVariables, TContext>,\n      'mutationKey'\n    >,\n  ): void {\n    this.#mutationDefaults.set(hashKey(mutationKey), {\n      mutationKey,\n      defaultOptions: options,\n    })\n  }\n\n  getMutationDefaults(\n    mutationKey: MutationKey,\n  ): MutationObserverOptions<any, any, any, any> {\n    const defaults = [...this.#mutationDefaults.values()]\n\n    let result: MutationObserverOptions<any, any, any, any> = {}\n\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {\n        result = { ...result, ...queryDefault.defaultOptions }\n      }\n    })\n\n    return result\n  }\n\n  defaultQueryOptions<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options:\n      | QueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey,\n          TPageParam\n        >\n      | DefaultedQueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey\n        >,\n  ): DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n    if (options._defaulted) {\n      return options as DefaultedQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        TQueryKey\n      >\n    }\n\n    const defaultedOptions = {\n      ...this.#defaultOptions.queries,\n      ...this.getQueryDefaults(options.queryKey),\n      ...options,\n      _defaulted: true,\n    }\n\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions,\n      )\n    }\n\n    // dependent default values\n    if (defaultedOptions.refetchOnReconnect === undefined) {\n      defaultedOptions.refetchOnReconnect =\n        defaultedOptions.networkMode !== 'always'\n    }\n    if (defaultedOptions.throwOnError === undefined) {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense\n    }\n\n    if (!defaultedOptions.networkMode && defaultedOptions.persister) {\n      defaultedOptions.networkMode = 'offlineFirst'\n    }\n\n    if (\n      defaultedOptions.enabled !== true &&\n      defaultedOptions.queryFn === skipToken\n    ) {\n      defaultedOptions.enabled = false\n    }\n\n    return defaultedOptions as DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T,\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.#defaultOptions.mutations,\n      ...(options?.mutationKey &&\n        this.getMutationDefaults(options.mutationKey)),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.#queryCache.clear()\n    this.#mutationCache.clear()\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}